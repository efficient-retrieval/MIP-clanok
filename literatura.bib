@InProceedings{10.1007/978-3-319-93803-5_1,
author="Kamatkar, Sadhana J.
and Kamble, Ajit
and Viloria, Amelec
and Hern{\'a}ndez-Fernandez, Lissette
and Cali, Ernesto Garc{\'i}a",
editor="Tan, Ying
and Shi, Yuhui
and Tang, Qirong",
title="Database Performance Tuning and Query Optimization",
booktitle="Data Mining and Big Data",
year="2018",
publisher="Springer International Publishing",
address="Cham",
pages="3--11",
abstract="Today, IT professionals are challenged with the task of ongoing improvements to achieve goals of businesses. Unfortunately, some factor/Resources, skill environment does not dynamically grow as fast as business needs. That sequence of events creates major obstacles for DB infrastructure, deployment, administration and maintenance. This paper discusses the performance issues, different bottlenecks such as CPU bottlenecks, Memory structures, Input output capacity issue, Database Design issues and Indexing issues. Also this paper address Tuning stages and how SQL queries can be optimized for better performance. In this paper we are focusing on query tuning tips {\&} tricks which can be applied to gain immediate performance gain by creating Query Execution Flow Chart. We demonstrate the application of this technique in an Employee Biometric Attendance Management System.",
isbn="978-3-319-93803-5"
}

@article{Database-indexing:-yesterday-and-today,
author = {Diakoff, Harry},
year = {2004},
month = {10},
pages = {},
title = {Database indexing: yesterday and today},
volume = {24},
journal = {The Indexer: The International Journal of Indexing},
doi = {10.3828/indexer.2004.24.2.11}
}

@inproceedings{10.1145/3009837.3009891,
author = {Scully, Ziv and Chlipala, Adam},
title = {A Program Optimization for Automatic Database Result Caching},
year = {2017},
isbn = {9781450346603},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3009837.3009891},
doi = {10.1145/3009837.3009891},
abstract = {Most popular Web applications rely on persistent databases based on languages like SQL for declarative specification of data models and the operations that read and modify them. As applications scale up in user base, they often face challenges responding quickly enough to the high volume of requests. A common aid is caching of database results in the application's memory space, taking advantage of program-specific knowledge of which caching schemes are sound and useful, embodied in handwritten modifications that make the program less maintainable. These modifications also require nontrivial reasoning about the read-write dependencies across operations. In this paper, we present a compiler optimization that automatically adds sound SQL caching to Web applications coded in the Ur/Web domain-specific functional language, with no modifications required to source code. We use a custom cache implementation that supports concurrent operations without compromising the transactional semantics of the database abstraction. Through experiments with microbenchmarks and production Ur/Web applications, we show that our optimization in many cases enables an easy doubling or more of an application's throughput, requiring nothing more than passing an extra command-line flag to the compiler.},
booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
pages = {271–284},
numpages = {14},
keywords = {database result caching, Web applications, program analysis, SQL},
location = {Paris, France},
series = {POPL '17}
}

@article{10.1145/3093333.3009891,
author = {Scully, Ziv and Chlipala, Adam},
title = {A Program Optimization for Automatic Database Result Caching},
year = {2017},
issue_date = {January 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/3093333.3009891},
doi = {10.1145/3093333.3009891},
abstract = {Most popular Web applications rely on persistent databases based on languages like SQL for declarative specification of data models and the operations that read and modify them. As applications scale up in user base, they often face challenges responding quickly enough to the high volume of requests. A common aid is caching of database results in the application's memory space, taking advantage of program-specific knowledge of which caching schemes are sound and useful, embodied in handwritten modifications that make the program less maintainable. These modifications also require nontrivial reasoning about the read-write dependencies across operations. In this paper, we present a compiler optimization that automatically adds sound SQL caching to Web applications coded in the Ur/Web domain-specific functional language, with no modifications required to source code. We use a custom cache implementation that supports concurrent operations without compromising the transactional semantics of the database abstraction. Through experiments with microbenchmarks and production Ur/Web applications, we show that our optimization in many cases enables an easy doubling or more of an application's throughput, requiring nothing more than passing an extra command-line flag to the compiler.},
journal = {SIGPLAN Not.},
month = {jan},
pages = {271–284},
numpages = {14},
keywords = {database result caching, Web applications, SQL, program analysis}
}